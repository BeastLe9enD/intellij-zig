{
  parserClass='org.ziglang.ZigParser'
  extends='com.intellij.extapi.psi.ASTWrapperPsiElement'
  psiClassPrefix='Zig'
  psiImplClassSuffix='Impl'
  psiPackage='org.ziglang.psi'
  psiImplPackage='org.ziglang.psi.impl'

  extends('.*Expr')=expr

  tokenTypeClass='org.ziglang.ZigTokenType'
  elementTypeHolderClass='org.ziglang.psi.ZigTypes'
  elementTypeClass='org.ziglang.ZigElementType'
}

zigFile ::= topLevelItem*

private endOfLine ::= SEMICOLON_SYM comment?
private comment ::= LINE_COMMENT
symbol ::= SYM { extends=expr }
string ::= STR { extends=expr }

private topLevelDeclaration ::=
 PUB_KEYWORD?
 (
   fnDeclaration
 | externDeclaration
 | globalVarDeclaration
 | useDeclaration
 )

topLevelItem ::= COMPTIME_KEYWORD block | topLevelDeclaration | testDeclaration
testDeclaration ::= TEST_KEYWORD string block
globalVarDeclaration ::= EXPORT_KEYWORD? variableDeclaration endOfLine
localVarDeclaration ::= COMPTIME_KEYWORD? variableDeclaration
variableDeclaration ::=
 (VAR_KEYWORD | CONST_KEYWORD) symbol (COLON_SYM typeExpr)?
 (ALIGN_KEYWORD LEFT_PAREN expr RIGHT_PAREN)?
 (SECTION_KEYWORD LEFT_PAREN expr RIGHT_PAREN)? EQ_SYM expr

containerField ::= symbol (COLON_SYM prefixOpExpr (EQ_SYM prefixOpExpr)?)? COMMA_SYM
containerMember ::=
 (
   containerField
 | fnDeclaration
 | globalVarDeclaration
 )

useDeclaration ::= USE_KEYWORD expr endOfLine
externDeclaration ::= EXTERN_KEYWORD string? (fnProto | variableDeclaration) endOfLine

fnProto ::=
 (
   NAKEDCC_KEYWORD
 | STDCALLCC_KEYWORD
 | EXTERN_KEYWORD
 | (ASYNC_KEYWORD (LEFT_PAREN expr RIGHT_PAREN)?)
 )?
 FN_KEYWORD symbol? parameterList (ALIGN_KEYWORD LEFT_PAREN expr RIGHT_PAREN)?
 (SECTION_KEYWORD LEFT_PAREN expr RIGHT_PAREN)? NOT_SYM? (typeExpr | VAR_KEYWORD)

fnDeclaration ::= (INLINE_KEYWORD | EXPORT_KEYWORD)? fnProto block

parameterList ::= LEFT_PAREN (paramDeclaration (COMMA_SYM paramDeclaration)*)? RIGHT_PAREN

paramDeclaration ::=
 (NOALIAS_KEYWORD | COMPTIME_KEYWORD)?
 (symbol COLON_SYM)?
 (typeExpr | VAR_KEYWORD | RANGE_SYM)

statement ::=
   localVarDeclaration endOfLine
 | deferBlock
 | defer endOfLine
 | blockExprBlock
 | expr? endOfLine

private ExprOrBlock ::= block | expr

block ::= (symbol COLON_SYM)? LEFT_BRACE statement* RIGHT_BRACE

asmOutput ::= COLON_SYM (asmOutputItem (COMMA_SYM asmOutputItem)*)? asmInput?
asmInput ::= COLON_SYM (asmInputItem (COMMA_SYM asmInputItem)*)? asmClobbers?
asmOutputItem ::= LEFT_BRACKET symbol RIGHT_BRACKET string LEFT_PAREN (symbol | SMALL_ARROW_SYM typeExpr) RIGHT_PAREN
asmInputItem ::= LEFT_BRACKET symbol RIGHT_BRACKET string LEFT_PAREN expr RIGHT_PAREN
asmClobbers ::= COLON_SYM (string (COMMA_SYM string)*)?

unwrapNullable ::= VERY_QUESTION_SYM expr
unwrapError ::= CATCH_KEYWORD (SEP_SYM symbol SEP_SYM)? expr

assignOperator ::=
   EQ_SYM
 | TIMES_ASSIGN_SYM
 | DIV_ASSIGN_SYM
 | MOD_ASSIGN_SYM
 | PLUS_ASSIGN_SYM
 | STAR_ASSIGN_SYM
 | MINUS_ASSIGN_SYM
 | SHL_ASSIGN_SYM
 | SHR_ASSIGN_SYM
 | AND_ASSIGN_SYM
 | EXPONENT_ASSIGN_SYM
 | OR_ASSIGN_SYM
 | STAR_MOD_ASSIGN_SYM
 | PLUS_MOD_ASSIGN_SYM
 | MINUS_MOD_ASSIGN_SYM

//BlockExpr(body) ::= Block | IfExpr(body) | IfErrorExpr(body) | TestExpr(body) | WhileExpr(body) | ForExpr(body) | switchExpr | CompTimeExpr(body) | SuspendExpr(body)
//Bnf泛型编程(雾
blockExprBlock ::=
   block
 | ifExprBlock
 | ifErrorExprBlock
 | testExprBlock
 | whileExprBlock
 | forExprBlock
 | switchStatement
 | compTimeExprBlock
 | suspendExprBlock

blockExprExprOrBlock ::=
   block
 | ifExprExprOrBlock
 | ifErrorExprExprOrBlock
 | testExprExprOrBlock
 | whileExprExprOrBlock
 | forExprExprOrBlock
 | switchStatement
 | compTimeExprExprOrBlock
 | suspendExprExprOrBlock

//CompTimeExpr(body) ::= "comptime" body
compTimeExprBlock ::= COMPTIME_KEYWORD block
compTimeExprExprOrBlock ::= COMPTIME_KEYWORD ExprOrBlock

switchStatement ::=
 SWITCH_KEYWORD
  LEFT_PAREN expr RIGHT_PAREN
  LEFT_BRACE switchProng* RIGHT_BRACE
switchItem ::= expr (RANGE_SYM expr)?
switchProng ::=
 (ELSE_KEYWORD | (switchItem (COMMA_SYM switchItem)*)?)
 ARROW_SYM
 (SEP_SYM STAR_SYM? symbol SEP_SYM)?
 expr COMMA_SYM

//ForExpr(body) ::=
// (symbol COLON_SYM)? INLINE_KEYWORD?
// FOR_KEYWORD LEFT_PAREN expr RIGHT_PAREN
//  option(SEP_SYM STAR_SYM? symbol option(COMMA_SYM symbol) SEP_SYM)
//   body
//  option(ELSE_KEYWORD BlockExpr(body))

forExprBlock ::=
 (symbol COLON_SYM)? INLINE_KEYWORD?
 FOR_KEYWORD LEFT_PAREN expr RIGHT_PAREN
  (SEP_SYM STAR_SYM? symbol (COMMA_SYM symbol)? SEP_SYM)?
   block
  (ELSE_KEYWORD blockExprBlock)?

forExprExprOrBlock ::=
 (symbol COLON_SYM)? INLINE_KEYWORD?
 FOR_KEYWORD LEFT_PAREN expr RIGHT_PAREN
  (SEP_SYM STAR_SYM? symbol (COMMA_SYM symbol)? SEP_SYM)?
   ExprOrBlock
  (ELSE_KEYWORD blockExprExprOrBlock)?

defer ::= (DEFER_KEYWORD | DEFERROR_KEYWORD) expr
deferBlock ::= (DEFER_KEYWORD | DEFERROR_KEYWORD) block

//IfExpr(body) ::= "if" LEFT_PAREN expr RIGHT_PAREN body option("else" BlockExpr(body))
ifExprBlock ::=
 IF_KEYWORD LEFT_PAREN expr RIGHT_PAREN
  block
 (ELSE_KEYWORD blockExprBlock)?
ifExprExprOrBlock ::=
 IF_KEYWORD LEFT_PAREN expr RIGHT_PAREN
  ExprOrBlock
 (ELSE_KEYWORD blockExprExprOrBlock)?

//SuspendExpr(body) ::= "suspend" option((SEP_SYM symbol SEP_SYM body))
suspendExprBlock ::= SUSPEND_KEYWORD (SEP_SYM symbol SEP_SYM block)?
suspendExprExprOrBlock ::= SUSPEND_KEYWORD (SEP_SYM symbol SEP_SYM ExprOrBlock)?

//IfErrorExpr(body) ::= "if" LEFT_PAREN expr RIGHT_PAREN option(SEP_SYM STAR_SYM? symbol SEP_SYM) body "else" SEP_SYM symbol SEP_SYM BlockExpr(body)
ifErrorExprBlock ::=
 IF_KEYWORD LEFT_PAREN expr RIGHT_PAREN
 (SEP_SYM STAR_SYM? symbol SEP_SYM)?
  block
 ELSE_KEYWORD SEP_SYM symbol SEP_SYM blockExprBlock
ifErrorExprExprOrBlock ::=
 IF_KEYWORD LEFT_PAREN expr RIGHT_PAREN
 (SEP_SYM STAR_SYM? symbol SEP_SYM)?
  ExprOrBlock
 ELSE_KEYWORD SEP_SYM symbol SEP_SYM blockExprExprOrBlock

//TestExpr(body) ::= "if" LEFT_PAREN expr RIGHT_PAREN option(SEP_SYM STAR_SYM? symbol SEP_SYM) body option("else" BlockExpr(body))
testExprBlock ::=
 IF_KEYWORD LEFT_PAREN expr RIGHT_PAREN
 (SEP_SYM STAR_SYM? symbol SEP_SYM)?
  block
 (ELSE_KEYWORD blockExprBlock)?
testExprExprOrBlock ::=
 IF_KEYWORD LEFT_PAREN expr RIGHT_PAREN
 (SEP_SYM STAR_SYM? symbol SEP_SYM)?
  ExprOrBlock
 (ELSE_KEYWORD blockExprExprOrBlock)?

//WhileExpr(body) ::= option(symbol COLON_SYM) option("inline") "while" LEFT_PAREN expr RIGHT_PAREN option(SEP_SYM STAR_SYM? symbol SEP_SYM) option(COLON_SYM LEFT_PAREN expr RIGHT_PAREN) body option("else" (SEP_SYM symbol SEP_SYM)? BlockExpr(body))
whileExprBlock ::=
 (symbol COLON_SYM)? INLINE_KEYWORD?
 WHILE_KEYWORD LEFT_PAREN expr RIGHT_PAREN
  (SEP_SYM STAR_SYM? symbol SEP_SYM)?
  (COLON_SYM LEFT_PAREN expr RIGHT_PAREN)?
   block
  (ELSE_KEYWORD (SEP_SYM symbol SEP_SYM)? blockExprBlock)?

whileExprExprOrBlock ::=
 (symbol COLON_SYM)? INLINE_KEYWORD?
 WHILE_KEYWORD LEFT_PAREN expr RIGHT_PAREN
  (SEP_SYM STAR_SYM? symbol SEP_SYM)?
  (COLON_SYM LEFT_PAREN expr RIGHT_PAREN)?
   ExprOrBlock

expr ::=
   tryExpr
 | returnExpr
  (ELSE_KEYWORD (SEP_SYM symbol SEP_SYM)? blockExprExprOrBlock)?
 | breakExpr
 | cancelExpr
 | resumeExpr
 | awaitExpr
 | assignExpr

asmExpr ::= ASM_KEYWORD VOLATILE_KEYWORD? LEFT_PAREN string asmOutput? RIGHT_PAREN
returnExpr ::= RETURN_KEYWORD expr?
tryExpr ::= TRY_KEYWORD expr
awaitExpr ::= AWAIT_KEYWORD expr
breakExpr ::= BREAK_KEYWORD (COLON_SYM symbol)? expr?
cancelExpr ::= CANCEL_KEYWORD expr
resumeExpr ::= RESUME_KEYWORD expr
assignExpr ::= unwrapExpr assignOperator unwrapExpr | unwrapExpr
unwrapExpr ::= boolOrExpr (unwrapNullable | unwrapError) | boolOrExpr
boolOrExpr ::= boolAndExpr OR_KEYWORD boolOrExpr | boolAndExpr
boolAndExpr ::= comparisonExpr AND_KEYWORD boolAndExpr | comparisonExpr
comparisonExpr ::= binaryOrExpr comparisonOperator binaryOrExpr | binaryOrExpr
binaryOrExpr ::= binaryXorExpr SEP_SYM binaryOrExpr | binaryXorExpr
binaryXorExpr ::= binaryAndExpr EXPONENT_SYM binaryXorExpr | binaryAndExpr
binaryAndExpr ::= bitShiftExpr AND_SYM binaryAndExpr | bitShiftExpr
bitShiftExpr ::= additionExpr bitShiftOperator bitShiftExpr | additionExpr
additionExpr ::= multiplyExpr additionOperator additionExpr | multiplyExpr
multiplyExpr ::= curlySuffixExpr multiplyOperator multiplyExpr | curlySuffixExpr
curlySuffixExpr ::= typeExpr containerInitSuffix?
typeExpr ::= (prefixOpExpr NOT_SYM prefixOpExpr) | prefixOpExpr
prefixOpExpr ::= prefixOp typeExpr | suffixOpExpr
suffixOpExpr ::=
   (ASYNC_KEYWORD (LEFT_PAREN expr RIGHT_PAREN)? primaryExpr fnCallSuffix)
 | primaryExpr (fnCallSuffix | arrayAccessSuffix | fieldAccessSuffix | sliceSuffix)?

private fieldAccessSuffix ::= DOT_SYM symbol
private fnCallSuffix ::= LEFT_PAREN (expr (COMMA_SYM expr)*)? RIGHT_PAREN
private arrayAccessSuffix ::= LEFT_BRACKET expr RIGHT_BRACKET
private sliceSuffix ::= LEFT_BRACKET expr SLICE_SYM expr? RIGHT_BRACKET
private containerInitSuffix ::= LEFT_BRACE containerInitBody? RIGHT_BRACE

bitShiftOperator ::= SHL_SYM | SHR_SYM
additionOperator ::= PLUS_SYM | MINUS_SYM | INC_SYM | PLUS_MOD_SYM | MINUS_MOD_SYM
multiplyOperator ::= SEP_SEP_SYM | STAR_SYM | DIV_SYM | MOD_SYM | STAR_STAR_SYM | STAR_MOD_SYM
comparisonOperator ::=
   EQUAL_SYM
 | UNEQUAL_SYM
 | LT_SYM
 | GT_SYM
 | LE_SYM
 | GE_SYM

containerInitBody ::=
   structLiteralField (COMMA_SYM structLiteralField)*
 | expr (COMMA_SYM expr)*

structLiteralField ::= DOT_SYM symbol EQ_SYM expr

prefixOp ::=
   NOT_SYM
 | MINUS
 | BITWISE_NOT_SYM
 | STAR_SYM
 | AND_SYM
  (
   ALIGN_KEYWORD LEFT_PAREN
   expr (COLON_SYM integer COLON_SYM integer)? RIGHT_PAREN
  )? CONST_KEYWORD? VOLATILE_KEYWORD?
 | QUESTION_SYM
 | VERY_QUESTION_SYM
 | MINUS_MOD_SYM
 | TRY_KEYWORD
 | AWAIT_KEYWORD

private primaryExpr ::=
   integer
 | float
 | string
 | char
 | keywordLiteral
 | boolean
 | null
 | blockExprExprOrBlock
 | symbol
 | macroCall
 | arrayType
 | fnProto
 | asmExpr
 | containerDeclaration
 | CONTINUE_KEYWORD (COLON_SYM symbol)?
 | errorSetDeclaration
 | groupedExpr

macroCall ::= AT_SYM symbol fnCallSuffix

arrayType ::=
 LEFT_BRACKET expr? RIGHT_BRACKET
 (ALIGN_KEYWORD LEFT_PAREN expr (COLON_SYM integer COLON_SYM integer)? RIGHT_PAREN)?
 CONST_KEYWORD? VOLATILE_KEYWORD? typeExpr

groupedExpr ::= LEFT_PAREN expr RIGHT_PAREN

integer ::= INT_LITERAL
float ::= FLOAT_LITERAL
boolean ::= TRUE_KEYWORD | FALSE_KEYWORD
null ::= NULL_KEYWORD
char ::= CHAR_LITERAL
keywordLiteral ::=
   UNDEFINED_KEYWORD
 | ERROR_KEYWORD
 | THIS_KEYWORD
 | UNREACHABLE_KEYWORD
 | SUSPEND_KEYWORD

errorSetDeclaration ::=
 ERROR_KEYWORD
 LEFT_BRACE (symbol (COMMA_SYM symbol)*)? RIGHT_BRACE

containerDeclaration ::=
 (EXTERN_KEYWORD | PACKED_KEYWORD)?
 (
   STRUCT_KEYWORD groupedExpr?
 | UNION_KEYWORD (ENUM_KEYWORD groupedExpr? | groupedExpr)?
 | ENUM_KEYWORD groupedExpr?
 )
 LEFT_BRACE containerMember* RIGHT_BRACE

