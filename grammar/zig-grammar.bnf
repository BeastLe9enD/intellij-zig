{
  parserClass='org.ziglang.ZigParser'
  extends='com.intellij.extapi.psi.ASTWrapperPsiElement'
  psiClassPrefix='Zig'
  psiImplClassSuffix='Impl'
  psiPackage='org.ziglang.psi'
  psiImplPackage='org.ziglang.psi.impl'

  tokenTypeClass='org.ziglang.ZigTokenType'
  elementTypeHolderClass='org.ziglang.psi.ZigTypes'
  elementTypeClass='org.ziglang.ZigElementType'
}

zigFile ::= topLevelItem* EOF

symbol ::= SYM
string ::= STR
topLevelItem ::= COMPTIME_KEYWORD block | topLevelDecl | testDecl
testDecl ::= TEST_KEYWORD string block
topLevelDecl ::= PUB_KEYWORD? (fnDef | externDecl | globalVarDecl | useDecl)
globalVarDecl ::= EXPORT_KEYWORD? variableDecl ";"
localVarDecl ::= COMPTIME_KEYWORD? variableDecl
variableDecl ::=
 (VAR_KEYWORD | CONST_KEYWORD) symbol (":" typeExpr)?
 (ALIGN_KEYWORD "(" expr ")")?
 (SECTION_KEYWORD "(" expr ")")? "=" expr

containerMember ::= (containerField | fnDef | globalVarDecl)
containerField ::= symbol (":" prefixOpExpr ("=" prefixOpExpr)?)? COMMA_SYM

useDecl ::= USE_KEYWORD expr ";"

externDecl ::= EXTERN_KEYWORD string? (fnProto | variableDecl) ";"

fnProto ::=
 (
   NAKEDCC_KEYWORD
 | STDCALLCC_KEYWORD
 | EXTERN_KEYWORD
 | (ASYNC_KEYWORD ("(" expr ")")?)
 )?
 FN_KEYWORD symbol? paramDeclList (ALIGN_KEYWORD "(" expr ")")?
 (SECTION_KEYWORD "(" expr ")")? "!"? (typeExpr | VAR_KEYWORD)

fnDef ::= (INLINE_KEYWORD | EXPORT_KEYWORD)? fnProto block

paramDeclList ::= "(" (paramDecl (COMMA_SYM paramDecl)*)? ")"

paramDecl ::=
 (NOALIAS_KEYWORD | COMPTIME_KEYWORD)?
 (symbol ":")?
 (typeExpr | VAR_KEYWORD | "...")

statement ::=
   localVarDecl ";"
 | deferblock
 | deferExpr ";"
 | blockExpr(block)
 | expr? ";"

private typeExpr ::= errorSetExpr
errorSetExpr ::= (prefixOpExpr "!" prefixOpExpr) | prefixOpExpr

private blockOrExpr ::= block | expr
expr ::= tryExpr | returnExpr | breakExpr | assignExpr | cancelExpr | resumeExpr
block ::= (symbol ":")? "{" statement* "}"

asmExpr ::= ASM_KEYWORD VOLATILE_KEYWORD? "(" string asmOutput? ")"
asmOutput ::= ":" (asmOutputItem (COMMA_SYM asmOutputItem)*)? asmInput?
asmInput ::= ":" (asmInputItem (COMMA_SYM asmInputItem)*)? asmClobbers?
asmOutputItem ::= "[" symbol "]" string "(" (symbol | "->" typeExpr) ")"
asmInputItem ::= "[" symbol "]" string "(" expr ")"
asmClobbers ::= ":" (string (COMMA_SYM string)*)?

unwrapExpr ::= boolOrExpr (unwrapNullable | unwrapError) | boolOrExpr
unwrapNullable ::= "??" expr
unwrapError ::= CATCH_KEYWORD ("|" symbol "|")? expr

assignExpr ::= unwrapExpr assignOperator unwrapExpr | unwrapExpr
assignOperator ::= "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | "&=" | "^=" | "|=" | "*%=" | "+%=" | "-%="

blockExpr(body) ::= block | IfExpr(body) | IfErrorExpr(body) | TestExpr(body) | WhileExpr(body) | ForExpr(body) | switchExpr | CompTimeExpr(body) | SuspendExpr(body)
CompTimeExpr(body) ::= "comptime" body

switchExpr ::= SWITCH_KEYWORD "(" expr ")" "{" switchProng* "}"
switchItem ::= expr | (expr "..." expr)
switchProng ::=
 (switchItem (COMMA_SYM switchItem) | ELSE_KEYWORD)
 "=>"
 ("|" "*"? symbol "|")?
 expr ","


ForExpr(body) ::=
 (symbol ":")? INLINE_KEYWORD?
 FOR_KEYWORD "(" expr ")"
  option("|" option("*") symbol option("," symbol) "|")
   body
  option(ELSE_KEYWORD blockExpr(body))

boolOrExpr ::= aoolAndExpr OR_KEYWORD boolOrExpr | aoolAndExpr
returnExpr ::= RETURN_KEYWORD expr?
tryExpr ::= TRY_KEYWORD expr
awaitExpr ::= AWAIT_KEYWORD expr
breakExpr ::= BREAK_KEYWORD (":" symbol)? expr?
cancelExpr ::= CANCEL_KEYWORD expr
resumeExpr ::= RESUME_KEYWORD expr
deferblock ::= (DEFER_KEYWORD | DEFERROR_KEYWORD) block
deferExpr ::= (DEFER_KEYWORD | DEFERROR_KEYWORD) expr

IfExpr(body) ::= "if" "(" expr ")" body option("else" blockExpr(body))

SuspendExpr(body) ::= "suspend" option(("|" symbol "|" body))

IfErrorExpr(body) ::= "if" "(" expr ")" option("|" option("*") symbol "|") body "else" "|" symbol "|" blockExpr(body)

TestExpr(body) ::= "if" "(" expr ")" option("|" option("*") symbol "|") body option("else" blockExpr(body))

WhileExpr(body) ::= option(symbol ":") option("inline") "while" "(" expr ")" option("|" option("*") symbol "|") option(":" "(" expr ")") body option("else" option("|" symbol "|") blockExpr(body))

aoolAndExpr ::= comparisonExpr "and" aoolAndExpr | comparisonExpr
comparisonExpr ::= binaryOrExpr comparisonOperator binaryOrExpr | binaryOrExpr
comparisonOperator ::= "==" | "!=" | "<" | ">" | "<=" | ">="
binaryOrExpr ::= binaryXorExpr "|" binaryOrExpr | binaryXorExpr
binaryXorExpr ::= binaryAndExpr "^" binaryXorExpr | binaryAndExpr
binaryAndExpr ::= bitShiftExpr "&" binaryAndExpr | bitShiftExpr
bitShiftExpr ::= additionExpr bitShiftOperator bitShiftExpr | additionExpr
bitShiftOperator ::= "<<" | ">>"
additionExpr ::= multiplyExpr additionOperator additionExpr | multiplyExpr
additionOperator ::= "+" | "-" | "++" | "+%" | "-%"
multiplyExpr ::= curlySuffixExpr multiplyOperator multiplyExpr | curlySuffixExpr
curlySuffixExpr ::= typeExpr containerInitExpr?
multiplyOperator ::= "||" | "*" | "/" | "%" | "**" | "*%"
prefixOpExpr ::= prefixOp errorSetExpr | suffixOpExpr

suffixOpExpr ::=
   ("async" ("(" expr ")")? primaryExpr fnCallExpr)
 | primaryExpr (fnCallExpr | arrayAccessExpr | fieldAccessExpr | sliceExpr)?

fieldAccessExpr ::= "." symbol
fnCallExpr ::= "(" expr (COMMA_SYM expr)* ")"
arrayAccessExpr ::= "[" expr "]"
sliceExpr ::= "[" expr ".." expr? "]"
containerInitExpr ::= "{" containerInitBody? "}"

containerInitBody ::=
   structLiteralField (COMMA_SYM structLiteralField)*
 | expr (COMMA_SYM expr)*

structLiteralField ::= "." symbol "=" expr

prefixOp ::= "!" | "-" | "~" | "*" | ("&" option("align" "(" expr option(":" integer ":" integer) ")" ) option("const") option("volatile")) | "?" | "??" | "-%" | "try" | "await"

primaryExpr ::=
   integer
 | float
 | string
 | char
 | keywordLiteral
 | boolean
 | null
 | groupedExpr
 | blockExpr(blockOrExpr)
 | symbol
 | "@" symbol fnCallExpr
 | arrayType
 | fnProto
 | asmExpr
 | containerDecl
 | ("continue" option(":" symbol))
 | errorSetDecl

arrayType ::= "[" expr? "]" option("align" "(" expr option(":" integer ":" integer) ")")) option("const") option("volatile") TypeExpr

groupedExpr ::= "(" expr ")"

integer ::= INT_LITERAL
float ::= FLOAT_LITERAL
boolean ::= TRUE_KEYWORD | FALSE_KEYWORD
null ::= NULL_KEYWORD
char ::= CHAR_LITERAL
keywordLiteral ::= "undefined" | "error" | "this" | "unreachable" | "suspend"

errorSetDecl ::= "error" "{" (symbol (COMMA_SYM symbol)*)? "}"

containerDecl ::= option("extern" | "packed")
  ("struct" groupedExpr? | "union" option("enum" groupedExpr? | groupedExpr) | ("enum" groupedExpr?))
  "{" containerMember* "}"

