{
  parserClass='org.ziglang.ZigParser'
  extends='com.intellij.extapi.psi.ASTWrapperPsiElement'
  psiClassPrefix='Zig'
  psiImplClassSuffix='Impl'
  psiPackage='org.ziglang.psi'
  psiImplPackage='org.ziglang.psi.impl'

  tokenTypeClass='org.ziglang.ZigTokenType'
  elementTypeHolderClass='org.ziglang.psi.ZigTypes'
  elementTypeClass='org.ziglang.ZigElementType'
}

Root ::= TopLevelItem* EOF

TopLevelItem ::= CompTimeExpression(Block) | TopLevelDecl | TestDecl

TestDecl ::= "test" String Block

TopLevelDecl ::= option("pub") (FnDef | ExternDecl | GlobalVarDecl | UseDecl)

GlobalVarDecl ::= option("export") VariableDeclaration ";"

LocalVarDecl ::= option("comptime") VariableDeclaration

VariableDeclaration ::= ("var" | "const") Symbol option(":" TypeExpr) option("align" "(" Expression ")") option("section" "(" Expression ")") "=" Expression

ContainerMember ::= (ContainerField | FnDef | GlobalVarDecl)

ContainerField ::= Symbol option(":" PrefixOpExpression option("=" PrefixOpExpression ","

UseDecl ::= "use" Expression ";"

ExternDecl ::= "extern" option(String) (FnProto | VariableDeclaration) ";"

FnProto ::= option("nakedcc" | "stdcallcc" | "extern" | ("async" option("(" Expression ")"))) "fn" option(Symbol) ParamDeclList option("align" "(" Expression ")") option("section" "(" Expression ")") option("!") (TypeExpr | "var")

FnDef ::= option("inline" | "export") FnProto Block

ParamDeclList ::= "(" list(ParamDecl, ",") ")"

ParamDecl ::= option("noalias" | "comptime") option(Symbol ":") (TypeExpr | "var" | "...")

Block ::= option(Symbol ":") "{" many(Statement) "}"

Statement ::= LocalVarDecl ";" | Defer(Block) | Defer(Expression) ";" | BlockExpression(Block) | Expression ";" | ";"

TypeExpr ::= ErrorSetExpr

ErrorSetExpr ::= (PrefixOpExpression "!" PrefixOpExpression) | PrefixOpExpression

BlockOrExpression ::= Block | Expression

Expression ::= TryExpression | ReturnExpression | BreakExpression | AssignmentExpression | CancelExpression | ResumeExpression

AsmExpression ::= "asm" option("volatile") "(" String option(AsmOutput) ")"

AsmOutput ::= ":" list(AsmOutputItem, ",") option(AsmInput)

AsmInput ::= ":" list(AsmInputItem, ",") option(AsmClobbers)

AsmOutputItem ::= "[" Symbol "]" String "(" (Symbol | "->" TypeExpr) ")"

AsmInputItem ::= "[" Symbol "]" String "(" Expression ")"

AsmClobbers ::= ":" list(String, ",")

UnwrapExpression ::= BoolOrExpression (UnwrapNullable | UnwrapError) | BoolOrExpression

UnwrapNullable ::= "??" Expression

UnwrapError ::= "catch" option("|" Symbol "|") Expression

AssignmentExpression ::= UnwrapExpression AssignmentOperator UnwrapExpression | UnwrapExpression

AssignmentOperator ::= "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | "&=" | "^=" | "|=" | "*%=" | "+%=" | "-%="

BlockExpression(body) ::= Block | IfExpression(body) | IfErrorExpression(body) | TestExpression(body) | WhileExpression(body) | ForExpression(body) | SwitchExpression | CompTimeExpression(body) | SuspendExpression(body)

CompTimeExpression(body) ::= "comptime" body

SwitchExpression ::= "switch" "(" Expression ")" "{" many(SwitchProng) "}"

SwitchProng ::= (list(SwitchItem, ",") | "else") "=>" option("|" option("*") Symbol "|") Expression ","

SwitchItem ::= Expression | (Expression "..." Expression)

ForExpression(body) ::= option(Symbol ":") option("inline") "for" "(" Expression ")" option("|" option("*") Symbol option("," Symbol) "|") body option("else" BlockExpression(body))

BoolOrExpression ::= BoolAndExpression "or" BoolOrExpression | BoolAndExpression

ReturnExpression ::= "return" option(Expression)

TryExpression ::= "try" Expression

AwaitExpression ::= "await" Expression

BreakExpression ::= "break" option(":" Symbol) option(Expression)

CancelExpression ::= "cancel" Expression;

ResumeExpression ::= "resume" Expression;

Defer(body) ::= ("defer" | "deferror") body

IfExpression(body) ::= "if" "(" Expression ")" body option("else" BlockExpression(body))

SuspendExpression(body) ::= "suspend" option(("|" Symbol "|" body))

IfErrorExpression(body) ::= "if" "(" Expression ")" option("|" option("*") Symbol "|") body "else" "|" Symbol "|" BlockExpression(body)

TestExpression(body) ::= "if" "(" Expression ")" option("|" option("*") Symbol "|") body option("else" BlockExpression(body))

WhileExpression(body) ::= option(Symbol ":") option("inline") "while" "(" Expression ")" option("|" option("*") Symbol "|") option(":" "(" Expression ")") body option("else" option("|" Symbol "|") BlockExpression(body))

BoolAndExpression ::= ComparisonExpression "and" BoolAndExpression | ComparisonExpression

ComparisonExpression ::= BinaryOrExpression ComparisonOperator BinaryOrExpression | BinaryOrExpression

ComparisonOperator ::= "==" | "!=" | "<" | ">" | "<=" | ">="

BinaryOrExpression ::= BinaryXorExpression "|" BinaryOrExpression | BinaryXorExpression

BinaryXorExpression ::= BinaryAndExpression "^" BinaryXorExpression | BinaryAndExpression

BinaryAndExpression ::= BitShiftExpression "&" BinaryAndExpression | BitShiftExpression

BitShiftExpression ::= AdditionExpression BitShiftOperator BitShiftExpression | AdditionExpression

BitShiftOperator ::= "<<" | ">>"

AdditionExpression ::= MultiplyExpression AdditionOperator AdditionExpression | MultiplyExpression

AdditionOperator ::= "+" | "-" | "++" | "+%" | "-%"

MultiplyExpression ::= CurlySuffixExpression MultiplyOperator MultiplyExpression | CurlySuffixExpression

CurlySuffixExpression ::= TypeExpr option(ContainerInitExpression)

MultiplyOperator ::= "||" | "*" | "/" | "%" | "**" | "*%"

PrefixOpExpression ::= PrefixOp ErrorSetExpr | SuffixOpExpression

SuffixOpExpression ::= ("async" option("(" Expression ")") PrimaryExpression FnCallExpression) | PrimaryExpression option(FnCallExpression | ArrayAccessExpression | FieldAccessExpression | SliceExpression)

FieldAccessExpression ::= "." Symbol

FnCallExpression ::= "(" list(Expression, ",") ")"

ArrayAccessExpression ::= "[" Expression "]"

SliceExpression ::= "[" Expression ".." option(Expression) "]"

ContainerInitExpression ::= "{" ContainerInitBody "}"

ContainerInitBody ::= list(StructLiteralField, ",") | list(Expression, ",")

StructLiteralField ::= "." Symbol "=" Expression

PrefixOp ::= "!" | "-" | "~" | "*" | ("&" option("align" "(" Expression option(":" Integer ":" Integer) ")" ) option("const") option("volatile")) | "?" | "??" | "-%" | "try" | "await"

PrimaryExpression ::= Integer | Float | String | CharLiteral | KeywordLiteral | GroupedExpression | BlockExpression(BlockOrExpression) | Symbol | ("@" Symbol FnCallExpression) | ArrayType | FnProto | AsmExpression | ContainerDecl | ("continue" option(":" Symbol)) | ErrorSetDecl

ArrayType ::= "[" option(Expression) "]" option("align" "(" Expression option(":" Integer ":" Integer) ")")) option("const") option("volatile") TypeExpr

GroupedExpression ::= "(" Expression ")"

KeywordLiteral ::= "true" | "false" | "null" | "undefined" | "error" | "this" | "unreachable" | "suspend"

ErrorSetDecl ::= "error" "{" list(Symbol, ",") "}"

ContainerDecl ::= ("extern" | "packed")?
  ("struct" GroupedExpression? | "union" option("enum" option(GroupedExpression) | GroupedExpression) | ("enum" GroupedExpression?)))
  "{" many(ContainerMember) "}"
